<?php
/**
 *
 * PHP 5
 *
 * Copyright (C) HMS Team
 *
 * Licensed under The MIT License
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     HMS Team
 * @package       dev.Setup.Common
 * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)
 */

define('CAKE_PATH', '../../../lib/Cake/');
define('APP_PATH', '../../../app/');

require_once (CAKE_PATH . 'Core/App.php');
require_once (CAKE_PATH . 'Core/Object.php');
require_once (CAKE_PATH . 'Event/CakeEventListener.php');
require_once (CAKE_PATH . 'Model/Model.php');
require_once (CAKE_PATH . 'Utility/CakeText.php');
require_once (APP_PATH . 'Model/AppModel.php');
require_once (APP_PATH . 'Model/Status.php');
require_once (APP_PATH . 'Model/Account.php');
require_once (APP_PATH . 'Model/Pin.php');
require_once (APP_PATH . 'Model/Group.php');
require_once (APP_PATH . 'Lib/CsvReader/CsvReader.php');

require_once ('Utils.php');

/**
 * This script is used to generate realistic(ish) data for use when manually testing HMS.
 * It is mainly powered by data generated by http://www.fakenamegenerator.com/
 * Data provided by http://www.fakenamegenerator.com/ is used under the
 * Creative Commons Attribution-Share Alike 3.0 United States license.
 */
class DataGenerator {

/**
 * The stock data used to populate other fields.
 * @var array
 */
	private $__stockData = array();

/**
 * List of ataken usernames
 * @var array
 */
	private $__takenUsernames = array();

/**
 * Array of members.
 * @var array
 */
	private $__members = array();

/**
 * Array of which members are in which groups.
 * @var array
 */
	private $__membersGroup = array();

/**
 * Array of accounts.
 * @var array
 */
	private $__accounts = array();

/**
 * Array of pins.
 * @var array
 */
	private $__pins = array();

/**
 * Array of rfid tags.
 * @var array
 */
	private $__rfidTags = array();

/**
 * Array of status updates.
 * @var array
 */
	private $__statusUpdates = array();

/**
 * Array of email records.
 * @var array
 */
	private $__emailRecords = array();

/**
 * Array of bank transaction records.
 * @var array
 */
    private $__bankTransaction = array();

/**
 * Array of bank csv records.
 * @var array
 */
    private $__bankCSV = array();
    
/**
 * Array of access log records.
 * @var array
 */
    private $__accessLog = array();
    
/**
 * Constructor
 */
	public function __construct() {
		$this->__parseCsv('./SourceData/FakeNameGeneratorData.csv');
	}

/**
 * Parse a CSV file, adding the data to the stockData array.
 * 
 * @param $filepath string Path to the .csv file to try and parse.
 */
	private function __parseCsv($filepath) {
		$csvReader = new CsvReader();

		if ($csvReader->readFile(makeAbsolutePath($filepath))) {
			$numLines = $csvReader->getNumLines();

			// If the .csv is sane, the first line is the headers
			$headers = $csvReader->getLine(0);

			if ($headers != null) {
				for ($i = 1; $i < $numLines; $i++) {
					// For every line, convert the indexed array to an associated array
					// using the headers as keys

					$line = $csvReader->getLine($i);
					if ($line != null && count($line) == count($headers) ) {
						$assocLine = array();
						$numLineParts = count($line);
						for ($j = 0; $j < $numLineParts; $j++) {
							$assocLine[$headers[$j]] = $line[$j];
						}

						array_push($this->__stockData, $assocLine);
					}
				}
			}
		}
	}

/**
 * Get the array of member data.
 * 
 * @return array Array of member data.
 */
	public function getMembersData() {
		return $this->__members;
	}

/**
 * Get the array of membersGroup data.
 *
 * @return array The array of membersGroup data.
 */
	public function getMembersGroupData() {
		return $this->__membersGroup;
	}

/**
 * Get the array of accounts data.
 *
 * @return array The array of accounts data.
 */
	public function getAccountsData() {
		return $this->__accounts;
	}

/**
 * Get the array of pins data.
 *
 * @return array The array of pins data.
 */
	public function getPinsData() {
		return $this->__pins;
	}

/**
 * Get the array of RFID tags data.
 *
 * @return array The array of RFID tags data.
 */
	public function getRfidTagsData() {
		return $this->__rfidTags;
	}

/**
 * Get the array of status updates data.
 *
 * @return array The array of status updates data.
 */
	public function getStatusUpdatesData() {
		return $this->__statusUpdates;
	}

/**
 * Get the array of email record data.
 *
 * @return array The array of email record data.
 */
	public function getEmailRecordData() {
		return $this->__emailRecords;
	}
    
/**
 * Get the array of bank transaction data.
 *
 * @return array The array of bank transactin data.
 */
	public function getBankTransactionData() {
      
        usort($this->__bankTransaction, array('DataGenerator','__transactionDateSortFunction'));
        
		return $this->__bankTransaction;
	}

/**
 * Get the array of email record data.
 *
 * @return array The array of email record data.
 */
	public function getBankCSVData() {
 
        usort($this->__bankCSV, function ($a, $b) {
              return $b['transaction_date'] - $a['transaction_date'];
              });
        
        return $this->__bankCSV;
	}
    
/**
 * Get the array of access log data.
 *
 * @return array The array of access log data.
 */
    public function getAccessLogData() {
 
        usort($this->__accessLog, function ($a, $b) {
              return $a['access_time'] - $a['access_time'];
              });
        
        return $this->__accessLog;
    }
    
/**
 * Generate a new member record
 *
 * @param int $membershipStage The stage of membership this member should be at, see Status model for details.
 * @param array $details Optional array of details that will be forced on the member being generated.
 */
	public function generateMember($membershipStage, $details = array()) {
		$memberId = count($this->__members) + 1;

		$creditLimit = 0;
		$balance = 0;
		$joinDate = '';
		$accountId = null;

		// Make it so they registered some time in the last year
		$now = time();
		$lastYear = strtotime('last year');
		$registerTimestamp = rand($lastYear, $now);

		if ((int)$membershipStage >= Status::PRE_MEMBER_3) {
			$accountId = $this->__generateAccount();
		}

		if ((int)$membershipStage >= Status::CURRENT_MEMBER) {
			$creditLimit = 5000;
			$balance = rand(-$creditLimit, 0);

			$joinDate = date('Y-m-d', $registerTimestamp);

			$this->__generatePin($memberId, $registerTimestamp);

			// Has this member set up access yet?
			// Pick a date within a week of the join date
			// and if that date has passed then member has set up a card
			$weekAfterJoin = strtotime('+1 week', $registerTimestamp);
			$registerTime = rand($registerTimestamp, $weekAfterJoin);
			if ($registerTime <= $now) {
				$this->__registerCard($memberId, $registerTime);
			}

			// Add the member to some random groups if they're a current member
			if ($membershipStage == Status::CURRENT_MEMBER) {
				// Will always be in current members group
				$groupList = array( Group::CURRENT_MEMBERS );

				$possibleGroups = array(
					Group::FULL_ACCESS,
					Group::GATEKEEPER_ADMIN,
					Group::SNACKSPACE_ADMIN,
					Group::MEMBERSHIP_ADMIN,
				);

				$numGroupsToAdd = rand(0, 2);
				for ($i = 0; $i < $numGroupsToAdd; $i++) {
					$index = array_rand($possibleGroups);
					$groupId = $possibleGroups[$index];
					array_splice($possibleGroups, $index, 1);

					array_push($groupList, $groupId);
				}

				// Groups can be overriden by the details array
				if ( isset($details['groups']) ) {
					$groupList = $details['groups'];
				}

				$this->__setMemberGroups($memberId, $groupList);
			}

            $numAccessRecords = rand (0,2);
            for ($i = 0; $i < $numAccessRecords; $i++) {
                $this->__generateAccessRecord($memberId, $registerTimestamp);
            }
		}

		// Need to generate status updates for all levels of membership
		// Spread the updates over some time
		$firstStatusUpdateTime = strtotime('-2 weeks', $registerTimestamp);
		$currentStatusUpdateTime = $firstStatusUpdateTime;
		for ($i = 0; $i < $membershipStage; $i++) {
			// The 'admin' making the change is the member
			// until the later membership stages
			$adminId = $memberId;
			if ($i >= Status::PRE_MEMBER_2 && count($this->__members) > 0) {
				$adminDataIdx = array_rand($this->__members);
				$adminId = $this->__members[$adminDataIdx]['member_id'];
			}

			$this->__generateStatusUpdate($memberId, $adminId, $i, $i + 1, $currentStatusUpdateTime);

			// Advance the status update time
			// may produce weirdness if it picks a time close to registerTimestamp with a few
			// status updates left to go but it shouldn't matter
			$currentStatusUpdateTime = rand($currentStatusUpdateTime, $registerTimestamp);
		}

		// Generate some unrealistic email records
		$numEmailRecords = rand(1, 4);
		$fromTimestamp = $registerTimestamp;
		$toTimestamp = $now;
		$subjects = array(
			'Contact Details',
			'Banking Details',
			'Membership Update',
			'Door Codes Have Changed',
		);
		for ($i = 0; $i < $numEmailRecords; $i++) {
			$recordTimestamp = rand($fromTimestamp, $toTimestamp);
			$fromTimestamp = $recordTimestamp;
			$subject = $subjects[array_rand($subjects)];
			$this->__generateEmailRecord($memberId, $subject, $recordTimestamp);
		}

		$stockData = $this->__getStockData();

		$firstname = $this->__useValOrDefault($details, 'firstname', $stockData['GivenName']);
		$surname = $this->__useValOrDefault($details, 'surname', $stockData['Surname']);
		$email = $this->__useValOrDefault($details, 'email', $stockData['EmailAddress']);
		$username = $this->__useValOrDefault($details, 'username', $stockData['Username']);

		while (in_array($username, $this->__takenUsernames)) {
			$username .= (string)rand(0, 9);
		}

		$address = array(
			$stockData['StreetAddress'],
			'',
			$stockData['City'],
			$stockData['ZipCode']
		);

		$contactNumber = $stockData['TelephoneNumber'];

		$unlockText = 'Welcome ' . $firstname;
//        echo "Member Id: " . $memberId . " Status: " . $membershipStage ."\n";
        // Need to genrate bank transaction and csv records
        if ((int)$membershipStage == Status::PRE_MEMBER_3) {
            // Gen a record that is less than 2 weeks old so if we run an audit we get some member movememnt
            $ran = rand(1,3);
            // random number 1 gen bank, 4 gen csv, else none
            if ($ran == 1 ) {
//                echo "pre bank\n";
                $this->__generateBankTransaction($accountId,
                                                 strtotime('-3 weeks'),
                                                 time(),
                                                 $firstname .' '. $surname
                                                 );
            } else if ($ran == 3) {
//                echo "pre csv\n";
                $this->__generateBankCSV($accountId,
                                         strtotime('-1 weeks'),
                                         time(),
                                         $firstname .' '. $surname
                                         );
//            } else {
//                echo "pre none\n";
            }
        
        } else if ((int)$membershipStage == Status::CURRENT_MEMBER) {
            // Gen 1-3 records that are over 1.5 months old (history)
            for ($i = 1; $i <= rand(1,3); $i++) {
                $this->__generateBankTransaction($accountId,
                                                 strtotime('-6 months'),
                                                 strtotime('-2 months 1 day'),
                                                 $firstname .' '. $surname
                                                 );
            }

            // now mix of records mostly stay
            $ran = rand(1, 6);
            if ($firstname == 'admin') {
            	// make sure we cant make the make our admin and ex member
            	$this->__generateBankTransaction($accountId,
                                                 strtotime('-1 week'),
                                                 time(),
                                                 $firstname .' '. $surname
                                                 );
            } else if ($ran == 5) {
                // some ex just to csv less than 2 weeks (cause ex aproval)
//                echo "current ex csv\n";
                $this->__generateBankCSV($accountId,
                                         strtotime('-1 weeks'),
                                         time(),
                                         $firstname .' '. $surname
                                         );
            } else if ($ran == 4) {
                // some warn (between 1.5 and 1 month)
//                echo "current warn bank\n";
                $this->__generateBankTransaction($accountId,
                                                 strtotime('-2 months'),
                                                 strtotime('-1 month 14 days'),
                                                 $firstname .' '. $surname
                                                 );
                // some also with a csv less that 1 weeks
                if (rand(1, 3) == 2) {
//                    echo "current warn csv\n";
                    $this->__generateBankCSV($accountId,
                                             strtotime('-1 week'),
                                             time(),
                                             $firstname .' '. $surname
                                             );
                }
            } else {
//                echo "currnet stay\n";
                $this->__generateBankTransaction($accountId,
                                                 strtotime('-1 month'),
                                                 time(),
                                                 $firstname .' '. $surname
                                                 );
            }
            
        } else if ((int)$membershipStage == Status::EX_MEMBER) {
            // Gen 1-3 records that are over 2 months old (history)
            for ($i = 1; $i <= rand(1,3); $i++) {
                $this->__generateBankTransaction($accountId,
                                                 strtotime('-6 months'),
                                                 strtotime('-2 month 1 day'),
                                                 $firstname .' '. $surname
                                                 );
            }
            // Gen a record that is less than 2 weeks old so if we run an audit we get some member movememnt
            $ran = rand(1, 4);
            // random number 1 gen bank, 4 gen csv, else none
            if ($ran == 2 ) {
//                echo "ex bank\n";
                $this->__generateBankTransaction($accountId,
                                                 strtotime('-3 weeks'),
                                                 time(),
                                                 $firstname .' '. $surname
                                                 );
            } else if ($ran == 4) {
//                echo "ex csv\n";
                $this->__generateBankCSV($accountId,
                                         strtotime('-1 weeks'),
                                         time(),
                                         $firstname .' '. $surname
                                         );
            }
        }
        
		// Clear any data that wouldn't be set yet
		if ((int)$membershipStage <= Status::PRE_MEMBER_1) {
			$firstname = null;
			$surname = null;
			$joinDate = '';
			$unlockText = null;
			$balance = 0;
			$creditLimit = 0;
			$username = null;
			$accountId = null;
			$address[0] = null;
			$address[1] = null;
			$address[2] = null;
			$address[3] = null;
			$contactNumber = null;
		}

		array_push($this->__takenUsernames, $username);

		$record = array(
			'member_id' => $memberId,
			'firstname' => $firstname,
			'surname' => $surname,
			'email' => $email,
			'join_date' => $joinDate,
			'unlock_text' => $unlockText,
			'balance' => $balance,
			'credit_limit' => $creditLimit,
			'member_status' => $membershipStage,
			'username' => $username,
			'account_id' => $accountId,
			'address_1' => $address[0],
			'address_2' => $address[1],
			'address_city' => $address[2],
			'address_postcode' => $address[3],
			'contact_number' => $contactNumber
		);

		array_push($this->__members, $record);
	}

/**
 * Create a new e-mail record.
 *
 * @param int $memberId The id of the member the e-mail was sent to.
 * @param string $subject The subject of the e-mail.
 * @param int $timestamp Unix timestamp for the time the e-mail was sent.
 */
	private function __generateEmailRecord($memberId, $subject, $timestamp) {
		$recordId = count($this->__emailRecords) + 1;

		$record = array(
			'hms_email_id' => $recordId,
			'member_id' => $memberId,
			'subject' => $subject,
			'timestamp' => date('Y-m-d H:i:s', $timestamp),
		);

		array_push($this->__emailRecords, $record);
	}

/**
 * Return $array[$key] if it is set, otherwise return $default.
 *
 * @param array $array The array to address.
 * @param mixed $key The index to use.
 * @param mixed $default The value to use if $val us not set.
 * @return mixed $array[$key]  if it is set, otherwise return $default.
 */
	private function __useValOrDefault($array, $key, $default) {
		if (array_key_exists($key, $array)) {
			return $array[$key];
		}

		return $default;
	}

/**
 * Set the groups which a member will belong to.
 *
 * @param int $memberId The id of the member who's groups we're setting.
 * @param array $groupList List of group id's.
 */
	private function __setMemberGroups($memberId, $groupList) {
		// Firstly remove all the current groups assigned to the member
		$numGroups = count($this->__membersGroup);
		for ($i = 0; $i < $numGroups; ) {
			if ($this->__membersGroup[$i]['member_id'] == $memberId) {
				array_splice($this->__membersGroup, $i, 1);
				// Don't increment since we've altered the array
				continue;
			}
			$i++;
		}

		// Now add a record for each of the items in $groupList
		foreach ($groupList as $groupId) {
			$record = array(
				'member_id' => $memberId,
				'grp_id' => $groupId,
			);

			array_push($this->__membersGroup, $record);
		}
	}

/**
 * Generate a status update record
 *
 * @param int $memberId The id of the member.
 * @param int $adminId The id of the admin making the change.
 * @param int $oldStatus The previous status of the member.
 * @param int $newStatus The new status of the member.
 * @param int $timestamp The timestamp of the update.
 */
	private function __generateStatusUpdate($memberId, $adminId, $oldStatus, $newStatus, $timestamp) {
		$recordId = count($this->__statusUpdates) + 1;

		$record = array(
			'id' => $recordId,
			'member_id' => $memberId,
			'admin_id' => $adminId,
			'old_status' => $oldStatus,
			'new_status' => $newStatus,
			'timestamp' => date('Y-m-d H:i:s', $timestamp),
		);

		array_push($this->__statusUpdates, $record);
	}

/**
 * Register an rfid card using the members pin.
 *
 * @param int $memberId The id of the member to register the card to.
 * @param int $registerTime The time the card was registered.
 */
	private function __registerCard($memberId, $registerTime) {
		// Registering a card effects the PIN
		$numPins = count($this->__pins);
		for ($i = 0; $i < $numPins; $i++) {
			if ($this->__pins[$i]['member_id'] == $memberId) {
				$this->__pins[$i]['state'] = 40;
				break;
			}
		}

		// The RFID serial are hex uid either 4, 7 or 10 bytes long
		$serialLenRemaining = 4;
		$serial = "";
		if (rand() % 5 == 0) {
			$serialLenRemaining = 7;
		} elseif (rand() % 10 == 0) {
            $serialLenRemaining = 10;
        }

		for ($i = 0; $i < $serialLenRemaining; $i++) {
			$serial .= dechex( rand( 0,255 ) );
		}

		// Make it so the card was used within the last month
		// (all members turn up at-least once a month right? ;) )
		$aMonthAgo = time('-1 month');

		$lastUsedMin = $aMonthAgo;
		// Can't have used it before it was registered...
		if ($aMonthAgo < $registerTime) {
			$lastUsedMin = $registerTime;
		}

		//  Pick a time between then and now
		$lastUsed = rand($lastUsedMin, time());

		// Now add an rfid record
		$record = array(
			'member_id' => $memberId,
			'rfid_serial' => $serial,
			'state' => 10,
			'last_used' => date('Y-m-d H:i:s', $lastUsed),
		);

		array_push($this->__rfidTags, $record);
	}

/**
 * Generate a new account record.
 *
 * @return int The id of the record.
 */
	private function __generateAccount() {
		$accountId = count($this->__accounts) + 1;

		$accountRef = $this->__generateUniqueEntry($this->__accounts, 'payment_ref', function() {
			return Account::generatePaymentRef();
		});

		$record = array(
			'account_id' => $accountId,
			'payment_ref' => $accountRef,
		);

		array_push($this->__accounts, $record);

		return $accountId;
	}

/**
 * Generate a new pin record
 *
 * @param int $memberId The id of the member the pin belongs to.
 * @param int $joinTimestamp The time the pin was generated.
 */
	private function __generatePin($memberId, $joinTimestamp) {
		$pinId = count($this->__pins) + 1;

		$pin = $this->__generateUniqueEntry($this->__pins, 'pin', function () {
			return Pin::generatePin();
		});

		$record = array(
			'pin_id' => $pinId,
			'pin' => $pin,
			'date_added' => date("Y-m-d H:i:s", $joinTimestamp),
			'expiry' => null,
			'state' => 30,
			'member_id' => $memberId
		);

		array_push($this->__pins, $record);
	}
    
/**
 * Generate a bank transaction for a given memberId with age between
 *
 * @param  int  $accountId
 * @param  int  $oldestTimestamp
 * @param  int  $newestTimestamp
 * @param  string  $name
 */
     private function __generateBankTransaction($accountId, $oldestTimestamp, $newestTimestamp, $name) {
         
        // fudge the date
        $transactionDate = rand($oldestTimestamp, $newestTimestamp);
         
        $record = array(
                        'transaction_date' => date('Y-m-d', $transactionDate),
                        'description' => $name .' '. $this->__accounts[$accountId -1 ]['payment_ref'] . ' ' . $accountId,
                        'amount' => rand(1, 7500)/100,
                        'bank_id' => 2,
                        'account_id' => $accountId,
                        );
         array_push($this->__bankTransaction, $record);
     }
    
    
/**
 * Generate a bank csv for a given accountId with age between
 *
 * @param  int  $accountId
 * @param  int  $oldestTimestamp
 * @param  int  $newestTimestamp
 * @param  string  $name
 */
     private function __generateBankCSV($accountId, $oldestTimestamp, $newestTimestamp, $name) {
 
        $transactionDate = rand($oldestTimestamp, $newestTimestamp);
        $record = array(
                        'transaction_date' => $transactionDate,        
                        'description' => $name .' '. $this->__accounts[$accountId -1 ]['payment_ref']. ' ' . $accountId,
                        'amount' => rand(1, 7500)/100,
                        );
         array_push($this->__bankCSV, $record);
     }

/**
 * Generate Access Record
 *
 * @param int $memberId The id of the member the pin belongs to.
 * @param int $joinTimestamp The time the pin was generated.
 */
     private function __generateAccessRecord($memberId, $joinTimestamp) {
 
        $accessTime = rand($joinTimestamp, time());
        $record = array(
                        'access_time' => date("Y-m-d H:i:s", $accessTime),
                        'member_id' => $memberId,
                        'access_result' => 10,
                        'rfid_serial' => $this->__rfidTags[count($this->__rfidTags)-1]['rfid_serial'],
                        );
        array_push($this->__accessLog, $record);
     }


/**
 * Given an array of array data, a key to the inner array, and a function to generate data, keep generating until the data is unique.
 *
 * @param array $records Array of existing records.
 * @param string $key Index in existing records to check.
 * @param function $genFunc The function used to generate new data.
 * @return mixed A unique value returned from $genFunc.
 */
	private function __generateUniqueEntry($records, $key, $genFunc) {
		$item = '';
		$isUnique = false;
		do {
			$item = $genFunc();
			$isUnique = true;

			foreach ($records as $record) {
				if ($record[$key] == $item) {
					$isUnique = false;
					break;
				}
			}

		} while (!$isUnique);

		return $item;
	}

/**
 * Pop a single element of the stock data and return it.
 *
 * @return array The data requested.
 */
	private function __getStockData() {
		$index = rand(0, count($this->__stockData) - 1);
		$data = $this->__stockData[$index];
		array_splice($this->__stockData, $index, 1);
		return $data;
	}
    
/**
 * array sort function
 *
 * @param
 * @param
 * @return
 */
    private static function __transactionDateSortFunction( $a, $b ) {
        return strtotime($a['transaction_date']) - strtotime($b['transaction_date']);
    }

}