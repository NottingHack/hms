<?php
/**
 *
 * PHP 5
 *
 * Copyright (C) HMS Team
 *
 * Licensed under The MIT License
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     HMS Team
 * @package       dev.Setup.Common
 * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)
 */

define('CAKE_PATH', '../../../lib/Cake/');
define('APP_PATH', '../../../app/');

require_once (CAKE_PATH . 'Core/App.php');
require_once (CAKE_PATH . 'Core/Object.php');
require_once (CAKE_PATH . 'Event/CakeEventListener.php');
require_once (CAKE_PATH . 'Model/Model.php');
require_once (CAKE_PATH . 'Utility/String.php');
require_once (APP_PATH . 'Model/AppModel.php');
require_once (APP_PATH . 'Model/Status.php');
require_once (APP_PATH . 'Model/Account.php');
require_once (APP_PATH . 'Model/Pin.php');
require_once (APP_PATH . 'Model/Group.php');
require_once (APP_PATH . 'Lib/CsvReader/CsvReader.php');

require_once ('Utils.php');

/**
 * This script is used to generate realistic(ish) data for use when manually testing HMS.
 * It is mainly powered by data generated by http://www.fakenamegenerator.com/
 * Data provided by http://www.fakenamegenerator.com/ is used under the
 * Creative Commons Attribution-Share Alike 3.0 United States license.
 */
class DataGenerator {

/**
 * The stock data used to populate other fields.
 * @var array
 */
	private $__stockData = array();

/**
 * List of ataken usernames
 * @var array
 */
	private $__takenUsernames = array();

/**
 * Array of members.
 * @var array
 */
	private $__members = array();

/**
 * Array of which members are in which groups.
 * @var array
 */
	private $__membersGroup = array();

/**
 * Array of accounts.
 * @var array
 */
	private $__accounts = array();

/**
 * Array of pins.
 * @var array
 */
	private $__pins = array();

/**
 * Array of rfid tags.
 * @var array
 */
	private $__rfidTags = array();

/**
 * Array of status updates.
 * @var array
 */
	private $__statusUpdates = array();

/**
 * Array of email records.
 * @var array
 */
	private $__emailRecords = array();

/**
 * Constructor
 */
	public function __construct() {
		$this->__parseCsv('./SourceData/FakeNameGeneratorData.csv');
	}

/**
 * Parse a CSV file, adding the data to the stockData array.
 * 
 * @param $filepath string Path to the .csv file to try and parse.
 */
	private function __parseCsv($filepath) {
		$csvReader = new CsvReader();

		if ($csvReader->readFile(makeAbsolutePath($filepath))) {
			$numLines = $csvReader->getNumLines();

			// If the .csv is sane, the first line is the headers
			$headers = $csvReader->getLine(0);

			if ($headers != null) {
				for ($i = 1; $i < $numLines; $i++) {
					// For every line, convert the indexed array to an associated array
					// using the headers as keys

					$line = $csvReader->getLine($i);
					if ($line != null && count($line) == count($headers) ) {
						$assocLine = array();
						$numLineParts = count($line);
						for ($j = 0; $j < $numLineParts; $j++) {
							$assocLine[$headers[$j]] = $line[$j];
						}

						array_push($this->__stockData, $assocLine);
					}
				}
			}
		}
	}

/**
 * Get the array of member data.
 * 
 * @return array Array of member data.
 */
	public function getMembersData() {
		return $this->__members;
	}

/**
 * Get the array of membersGroup data.
 *
 * @return array The array of membersGroup data.
 */
	public function getMembersGroupData() {
		return $this->__membersGroup;
	}

/**
 * Get the array of accounts data.
 *
 * @return array The array of accounts data.
 */
	public function getAccountsData() {
		return $this->__accounts;
	}

/**
 * Get the array of pins data.
 *
 * @return array The array of pins data.
 */
	public function getPinsData() {
		return $this->__pins;
	}

/**
 * Get the array of RFID tags data.
 *
 * @return array The array of RFID tags data.
 */
	public function getRfidTagsData() {
		return $this->__rfidTags;
	}

/**
 * Get the array of status updates data.
 *
 * @return array The array of status updates data.
 */
	public function getStatusUpdatesData() {
		return $this->__statusUpdates;
	}

/**
 * Get the array of email record data.
 *
 * @return array The array of email record data.
 */
	public function getEmailRecordData() {
		return $this->__emailRecords;
	}

/**
 * Generate a new member record
 *
 * @param int $membershipStage The stage of membership this member should be at, see Status model for details.
 * @param array $details Optional array of details that will be forced on the member being generated.
 */
	public function generateMember($membershipStage, $details = array()) {
		$memberId = count($this->__members) + 1;

		$creditLimit = 0;
		$balance = 0;
		$joinDate = '';
		$accountId = null;

		// Make it so they registered some time in the last year
		$now = time();
		$lastYear = strtotime('last year');
		$registerTimestamp = rand($lastYear, $now);

		if ((int)$membershipStage >= Status::PRE_MEMBER_3) {
			$accountId = $this->__generateAccount();
		}

		if ((int)$membershipStage >= Status::CURRENT_MEMBER) {
			$creditLimit = 5000;
			$balance = rand(-$creditLimit, 0);

			$joinDate = date('Y-m-d', $registerTimestamp);

			$this->__generatePin($memberId, $registerTimestamp);

			// Has this member set up access yet?
			// Pick a date within a week of the join date
			// and if that date has passed then member has set up a card
			$weekAfterJoin = strtotime('+1 week', $registerTimestamp);
			$registerTime = rand($registerTimestamp, $weekAfterJoin);
			if ($registerTime <= $now) {
				$this->__registerCard($memberId, $registerTime);
			}

			// Add the member to some random groups if they're a current member
			if ($membershipStage == Status::CURRENT_MEMBER) {
				// Will always be in current members group
				$groupList = array( Group::CURRENT_MEMBERS );

				$possibleGroups = array(
					Group::FULL_ACCESS,
					Group::GATEKEEPER_ADMIN,
					Group::SNACKSPACE_ADMIN,
					Group::MEMBERSHIP_ADMIN,
				);

				$numGroupsToAdd = rand(0, 2);
				for ($i = 0; $i < $numGroupsToAdd; $i++) {
					$index = array_rand($possibleGroups);
					$groupId = $possibleGroups[$index];
					array_splice($possibleGroups, $index, 1);

					array_push($groupList, $groupId);
				}

				// Groups can be overriden by the details array
				if ( isset($details['groups']) ) {
					$groupList = $details['groups'];
				}

				$this->__setMemberGroups($memberId, $groupList);
			}
		}

		// Need to generate status updates for all levels of membership
		// Spread the updates over some time
		$firstStatusUpdateTime = strtotime('-2 weeks', $registerTimestamp);
		$currentStatusUpdateTime = $firstStatusUpdateTime;
		for ($i = 0; $i < $membershipStage; $i++) {
			// The 'admin' making the change is the member
			// until the later membership stages
			$adminId = $memberId;
			if ($i >= Status::PRE_MEMBER_2 && count($this->__members) > 0) {
				$adminDataIdx = array_rand($this->__members);
				$adminId = $this->__members[$adminDataIdx]['member_id'];
			}

			$this->__generateStatusUpdate($memberId, $adminId, $i, $i + 1, $currentStatusUpdateTime);

			// Advance the status update time
			// may produce weirdness if it picks a time close to registerTimestamp with a few
			// status updates left to go but it shouldn't matter
			$currentStatusUpdateTime = rand($currentStatusUpdateTime, $registerTimestamp);
		}

		// Generate some unrealistic email records
		$numEmailRecords = rand(1, 4);
		$fromTimestamp = $registerTimestamp;
		$toTimestamp = $now;
		$subjects = array(
			'Contact Details',
			'Banking Details',
			'Membership Update',
			'Door Codes Have Changed',
		);
		for ($i = 0; $i < $numEmailRecords; $i++) {
			$recordTimestamp = rand($fromTimestamp, $toTimestamp);
			$fromTimestamp = $recordTimestamp;
			$subject = $subjects[array_rand($subjects)];
			$this->__generateEmailRecord($memberId, $subject, $recordTimestamp);
		}

		$stockData = $this->__getStockData();

		$firstname = $this->__useValOrDefault($details, 'firstname', $stockData['GivenName']);
		$surname = $this->__useValOrDefault($details, 'surname', $stockData['Surname']);
		$email = $this->__useValOrDefault($details, 'email', $stockData['EmailAddress']);
		$username = $this->__useValOrDefault($details, 'username', $stockData['Username']);

		while (in_array($username, $this->__takenUsernames)) {
			$username .= (string)rand(0, 9);
		}

		$address = array(
			$stockData['StreetAddress'],
			'',
			$stockData['City'],
			$stockData['ZipCode']
		);

		$contactNumber = $stockData['TelephoneNumber'];

		$unlockText = 'Welcome ' . $firstname;

		// Clear any data that wouldn't be set yet
		if ((int)$membershipStage <= Status::PRE_MEMBER_1) {
			$firstname = null;
			$surname = null;
			$joinDate = '';
			$unlockText = null;
			$balance = 0;
			$creditLimit = 0;
			$username = null;
			$accountId = null;
			$address[0] = null;
			$address[1] = null;
			$address[2] = null;
			$address[3] = null;
			$contactNumber = null;
		}

		array_push($this->__takenUsernames, $username);

		$record = array(
			'member_id' => $memberId,
			'firstname' => $firstname,
			'surname' => $surname,
			'email' => $email,
			'join_date' => $joinDate,
			'unlock_text' => $unlockText,
			'balance' => $balance,
			'credit_limit' => $creditLimit,
			'member_status' => $membershipStage,
			'username' => $username,
			'account_id' => $accountId,
			'address_1' => $address[0],
			'address_2' => $address[1],
			'address_city' => $address[2],
			'address_postcode' => $address[3],
			'contact_number' => $contactNumber
		);

		array_push($this->__members, $record);
	}

/**
 * Create a new e-mail record.
 *
 * @param int $memberId The id of the member the e-mail was sent to.
 * @param string $subject The subject of the e-mail.
 * @param int $timestamp Unix timestamp for the time the e-mail was sent.
 */
	private function __generateEmailRecord($memberId, $subject, $timestamp) {
		$recordId = count($this->__emailRecords) + 1;

		$record = array(
			'hms_email_id' => $recordId,
			'member_id' => $memberId,
			'subject' => $subject,
			'timestamp' => date('Y-m-d H:i:s', $timestamp),
		);

		array_push($this->__emailRecords, $record);
	}

/**
 * Return $array[$key] if it is set, otherwise return $default.
 *
 * @param array $array The array to address.
 * @param mixed $key The index to use.
 * @param mixed $default The value to use if $val us not set.
 * @return mixed $array[$key]  if it is set, otherwise return $default.
 */
	private function __useValOrDefault($array, $key, $default) {
		if (array_key_exists($key, $array)) {
			return $array[$key];
		}

		return $default;
	}

/**
 * Set the groups which a member will belong to.
 *
 * @param int $memberId The id of the member who's groups we're setting.
 * @param array $groupList List of group id's.
 */
	private function __setMemberGroups($memberId, $groupList) {
		// Firstly remove all the current groups assigned to the member
		$numGroups = count($this->__membersGroup);
		for ($i = 0; $i < $numGroups; ) {
			if ($this->__membersGroup[$i]['member_id'] == $memberId) {
				array_splice($this->__membersGroup, $i, 1);
				// Don't increment since we've altered the array
				continue;
			}
			$i++;
		}

		// Now add a record for each of the items in $groupList
		foreach ($groupList as $groupId) {
			$record = array(
				'member_id' => $memberId,
				'grp_id' => $groupId,
			);

			array_push($this->__membersGroup, $record);
		}
	}

/**
 * Generate a status update record
 *
 * @param int $memberId The id of the member.
 * @param int $adminId The id of the admin making the change.
 * @param int $oldStatus The previous status of the member.
 * @param int $newStatus The new status of the member.
 * @param int $timestamp The timestamp of the update.
 */
	private function __generateStatusUpdate($memberId, $adminId, $oldStatus, $newStatus, $timestamp) {
		$recordId = count($this->__statusUpdates) + 1;

		$record = array(
			'id' => $recordId,
			'member_id' => $memberId,
			'admin_id' => $adminId,
			'old_status' => $oldStatus,
			'new_status' => $newStatus,
			'timestamp' => date('Y-m-d H:i:s', $timestamp),
		);

		array_push($this->__statusUpdates, $record);
	}

/**
 * Register an rfid card using the members pin.
 *
 * @param int $memberId The id of the member to register the card to.
 * @param int $registerTime The time the card was registered.
 */
	private function __registerCard($memberId, $registerTime) {
		// Registering a card effects the PIN
		$numPins = count($this->__pins);
		for ($i = 0; $i < $numPins; $i++) {
			if ($this->__pins[$i]['member_id'] == $memberId) {
				$this->__pins[$i]['state'] = 40;
				break;
			}
		}

		// The RFID serial seems to be between 9 and 10 numbers starting with 1
		$serialLenRemaining = 9;
		$serial = '1';
		if (rand() % 2 == 0) {
			$serialLenRemaining = 8;
		}

		for ($i = 0; $i < $serialLenRemaining; $i++) {
			$serial .= rand(0, 9);
		}

		// Make it so the card was used within the last month
		// (all members turn up at-least once a month right? ;) )
		$aMonthAgo = time('-1 month');

		$lastUsedMin = $aMonthAgo;
		// Can't have used it before it was registered...
		if ($aMonthAgo < $registerTime) {
			$lastUsedMin = $registerTime;
		}

		//  Pick a time between then and now
		$lastUsed = rand($lastUsedMin, time());

		// Now add an rfid record
		$record = array(
			'member_id' => $memberId,
			'rfid_serial' => $serial,
			'state' => 10,
			'last_used' => $lastUsed,
		);

		array_push($this->__rfidTags, $record);
	}

/**
 * Generate a new account record.
 *
 * @return int The id of the record.
 */
	private function __generateAccount() {
		$accountId = count($this->__accounts) + 1;

		$accountRef = $this->__generateUniqueEntry($this->__accounts, 'payment_ref', function() {
			return Account::generatePaymentRef();
		});

		$record = array(
			'account_id' => $accountId,
			'payment_ref' => $accountRef,
		);

		array_push($this->__accounts, $record);

		return $accountId;
	}

/**
 * Generate a new pin record
 *
 * @param int $memberId The id of the member the pin belongs to.
 * @param int $joinTimestamp The time the pin was generated.
 */
	private function __generatePin($memberId, $joinTimestamp) {
		$pinId = count($this->__pins) + 1;

		$pin = $this->__generateUniqueEntry($this->__pins, 'pin', function () {
			return Pin::generatePin();
		});

		$record = array(
			'pin_id' => $pinId,
			'pin' => $pin,
			'date_added' => date("Y-m-d H:i:s", $joinTimestamp),
			'expiry' => null,
			'state' => 30,
			'member_id' => $memberId
		);

		array_push($this->__pins, $record);
	}

/**
 * Given an array of array data, a key to the inner array, and a function to generate data, keep generating until the data is unique.
 *
 * @param array $records Array of existing records.
 * @param string $key Index in existing records to check.
 * @param function $genFunc The function used to generate new data.
 * @return mixed A unique value returned from $genFunc.
 */
	private function __generateUniqueEntry($records, $key, $genFunc) {
		$item = '';
		$isUnique = false;
		do {
			$item = $genFunc();
			$isUnique = true;

			foreach ($records as $record) {
				if ($record[$key] == $item) {
					$isUnique = false;
					break;
				}
			}

		} while (!$isUnique);

		return $item;
	}

/**
 * Pop a single element of the stock data and return it.
 *
 * @return array The data requested.
 */
	private function __getStockData() {
		$index = rand(0, count($this->__stockData) - 1);
		$data = $this->__stockData[$index];
		array_splice($this->__stockData, $index, 1);
		return $data;
	}
}